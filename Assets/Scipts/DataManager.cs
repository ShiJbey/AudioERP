using System.Collections.Generic;
using UnityEngine;
using Accord.Math;
using System.Threading;
using System.Linq;
using System.IO;

namespace AudioERP
{
    public class DataManager : MonoBehaviour, LSLDataListener
    {
        // Maintains concurrency between the gameobject and data fetching thread
        private Mutex dataHistoryMut = new Mutex();
        // Data samples read from the inlet
        private List<float[]> data = new List<float[]>();
        // Epochs generated by reach stimuli event
        private List<Epoch> epochs = new List<Epoch>();
        // Organizes Epochs by the transform of the gameobject that triggered the event
        private Dictionary<Transform, List<Epoch>> sortedEpochs = new Dictionary<Transform, List<Epoch>>();
        // List of epochs that have been averaged within a sequence of trials
        // according to the stimuli origin transform
        private List<Epoch> averagedEpochs = new List<Epoch>();
        
        [Header("Data Format")]
        // Channel indices that we want to track for classification
        public int[] desiredChannels;

        [Header("Epoch Attributes")]
        // Start time offset relative to the event time of the event
        public float startTimeOffset = 0f;
        // Total duration of the epoch
        public float duration = 1f;

        [Header("Raw Data Filtering")]
        // Should the data be filtered prior to splitting into epochs
        public bool filterData = true;
        // Cut off  value in Hertz for the lowpass filter
        public float lowpassCutOff = 60f;

        [Header("Downsampling Data")]
        public bool downSample = false;
        public float downSampleRate = 128f;

        // Use this for initialization;
        void Start()
        {
            // Do Nothing
        }

        // Update is called once per frame
        void Update()
        {
            // Do Nothing
        }

        // Low pass filter for voltage channels
        public static float[] lowpassFilter(float[] input, float sampleRate, float cutoff)
        {
            // Code borrowed from:
            // https://www.quora.com/Whats-the-C-coding-for-a-low-pass-filter
            float RC = 1.0f / (cutoff * 2 * 3.14f);
            float dt = 1.0f / sampleRate;
            float alpha = dt / (RC + dt);
            float[] output = new float[input.Length];
            output[0] = input[0];
            for (int i = 1; i < input.Length; i++)
            {
                output[i] = output[i - 1] + (alpha * (input[i] - output[i - 1]));
            }
            return output;
        }

        // Runs a lowpass filter across the stored data samples
        public void FilterData()
        {
            float sampleRate = this.GetComponent<UnityLSLConnector>().sampleRate;
            // Convert data to a matrix for accord
            this.dataHistoryMut.WaitOne();
            float[][] dataArray = this.data.ToArray();
            this.dataHistoryMut.ReleaseMutex();
            // Loop though each column except for the first (time stamps)
            // and apply the lowpass filter
            for (int i = 1; i < dataArray.Columns(); i++)
            {
                // Filter the column
                float[] filteredChannelData = DataManager.lowpassFilter(dataArray.GetColumn(i), sampleRate, lowpassCutOff);
                // Set it back in the matrix
                dataArray.SetColumn(i, filteredChannelData);
            }
            // Convert the matrix back to the list representation
            this.dataHistoryMut.WaitOne();
            this.data = dataArray.ToList();
            this.dataHistoryMut.ReleaseMutex();
        }

        // Deletes all recorded Epochs
        public void ClearEpochs()
        {
            this.epochs.Clear();
        }

        // Deletes all sorted Epochs
        public void ClearSortedEpochs()
        {
            this.sortedEpochs.Clear();
        }

        // Deletes all averaged Epochs
        public void ClearAveragedEpochs()
        {
            this.averagedEpochs.Clear();
        }

        // Clears all data samples that have been stored
        public void ClearData()
        {
            this.dataHistoryMut.WaitOne();
            this.data.Clear();
            this.dataHistoryMut.ReleaseMutex();
        }

        // Returns all the recorded Epochs
        public List<Epoch> GetAllEpochs()
        {
            return this.epochs;
        }

        // Adds an epoch to the general list of epochs
        public void AddEpoch(Epoch epoch)
        {
            this.epochs.Add(epoch);
        }

        // Adds a new epoch to the sorted dictionary of epochs
        public void AddSortedEpoch(Transform trans, Epoch epoch)
        {
            if (this.sortedEpochs.ContainsKey(trans))
            {
                this.sortedEpochs[trans].Add(epoch);
            }
            else
            {
                List<Epoch> epochList = new List<Epoch>();
                epochList.Add(epoch);
                this.sortedEpochs.Add(trans, epochList);
            }
        }

        // Fills the processedEpochs list with epochs that have been averaged
        public void ProcessEpochs(ERPMenu.ExecutionMode mode)
        {
            if (filterData)
            {
                FilterData();
            }
            if (downSample)
            {
                DownSampleData(downSampleRate);
            }
            FillEpochs();
            FixEpochSizes();
            SortEpochs();
            if (mode == ERPMenu.ExecutionMode.LIVE)
            {
                averagedEpochs.Clear();
            }
            averagedEpochs.AddRange(AverageEpochs());
        }

        // Removes some samples from the data history 
        public void DownSampleData(float targetRate)
        {
            float currentSamplingRate = (float)this.GetComponent<UnityLSLConnector>().sampleRate;
            if (targetRate < currentSamplingRate)
            {
                this.dataHistoryMut.WaitOne();
                int numToSkip = Mathf.RoundToInt(currentSamplingRate / targetRate);
                for (int i = 0; i < this.data.Count; i++)
                {
                    if (i % numToSkip != 0)
                    {
                        this.data.RemoveAt(i);
                    }
                }
                this.dataHistoryMut.ReleaseMutex();
            }
        }

        // Adds each entry in epochs to the Sorted Epochs Dictionary
        void SortEpochs()
        {
            foreach(Epoch epoch in epochs)
            {
                AddSortedEpoch(epoch.GetEventOrigin(), epoch);
            }
        }

        // Resizes the data matrices of all the
        // epochs to be [(duration - starttimeOffset)*sampleRate X nChannels]
        public void FixEpochSizes()
        {
            UnityLSLConnector lslConnector = this.GetComponent<UnityLSLConnector>();

            int nominalSamplesPerEpoch = (this.downSample) ? 
                Mathf.CeilToInt(this.duration * this.downSampleRate) : 
                Mathf.CeilToInt(this.duration * (float)lslConnector.sampleRate);

            foreach (Epoch epoch in epochs)
            {
                int numSamples = epoch.GetData().Rows();
                int difference = Mathf.Abs(nominalSamplesPerEpoch - numSamples);
                if (numSamples < nominalSamplesPerEpoch)
                {
                    // Pad the end of the matrix with the values in the last row
                    float[] lastRow = epoch.GetData().GetRow(numSamples - 1);
                    for (int i = 0; i < difference; ++i)
                    {
                        epoch.SetData(epoch.GetData().InsertRow(lastRow, numSamples + i));
                    }
                }
                else if (numSamples > nominalSamplesPerEpoch)
                {
                    // Remove the last rows of the matrix
                    int[] indicesToRemove = new int[difference];
                    for (int i = 0; i < difference; i++)
                    {
                        indicesToRemove[i] = (numSamples - 1) - i;
                    }
                    epoch.SetData(epoch.GetData().Remove(indicesToRemove, null));
                }
            }
        }

        // Averages the epoch data of the epochs in each on of
        // the lists contained in the eventEpochs Dictionary
        public List<Epoch> AverageEpochs()
        {
            List<Epoch> averagedEpochs = new List<Epoch>();

            foreach (KeyValuePair<Transform, List<Epoch>> entry in sortedEpochs)
            {
                if (entry.Value.Count > 0)
                {
                    // Create empty matrix of zeros to hold the new matrix of averaged data
                    float[,] averagedData 
                        = Accord.Math.Matrix.Zeros<float>(entry.Value[0].GetData().Rows(),
                            entry.Value[0].GetData().Columns());
                    // Sum the data
                    foreach (Epoch epoch in entry.Value)
                    {
                        averagedData.Add(epoch.GetData());
                    }
                    // Divide by the total number of epochs
                    averagedData.Divide(entry.Value.Count);
                    // Create the new averaged epoch and add it to the list
                    averagedEpochs.Add(
                        new Epoch(entry.Key, entry.Value[0].GetEventTime(),
                            entry.Value[0].IsTarget(), averagedData));
                }
                
            }
            return averagedEpochs;
        }

        // Iterate through the epochs and give each one the 
        // segment of the data history that corresponds to its
        // timeframe
        public void FillEpochs()
        {
            foreach (Epoch epoch in epochs)
            {
                int startSampleIndex = this.GetIndexOfSample(epoch.GetEventTime() + this.startTimeOffset);
                int endSampleIndex = this.GetIndexOfSample(epoch.GetEventTime() + this.startTimeOffset + this.duration);
                int range = endSampleIndex - startSampleIndex;
                if (range > 0)
                {
                    this.dataHistoryMut.WaitOne();
                    float[,] dataSubset = Accord.Math.Matrix.Create(this.data.GetRange(startSampleIndex, range).ToArray());
                    dataSubset = Accord.Math.Matrix.RemoveColumn<float>(dataSubset, 0);
                    epoch.SetData(dataSubset);
                    this.dataHistoryMut.ReleaseMutex();
                }
            }
        }

        // Given the time of a sample, returns the index of the
        // sample with the closest time without going over
        public int GetIndexOfSample(float sampleTime)
        {
            // Default the index to be the last data sample
            int index = data.Count - 1;
            this.dataHistoryMut.WaitOne();
            for (int i = 0; i < data.Count; ++i)
            {
                if (data[i][0] == sampleTime)
                {
                    index = i;
                    break;
                }
                else if (data[i][0] > sampleTime && i > 1)
                {
                    index = i - 1;
                    break;
                }
            }
            this.dataHistoryMut.ReleaseMutex();
            return index;
        }

        // Adds a sample to the data list
        public void PushDataSample(float[] dataSample, float sampleTime)
        {
            this.dataHistoryMut.WaitOne();
            this.data.Add(Accord.Math.Matrix.Concatenate<float>(sampleTime, dataSample));
            this.dataHistoryMut.ReleaseMutex();
        }

        // Gets all of the remaining data samples off the LSL inlet that
        // belong to stored epochs
        public void PullRemainingData()
        {
            // Read from inlet until sample time is outside of current  epoch durations
            double sampleTime = 0;
            UnityLSLConnector lslConnector = GetComponent<UnityLSLConnector>();
            while (sampleTime < epochs[epochs.Count - 1].GetEventTime() + duration)
            {
                sampleTime = lslConnector.PullSample();
            }
        }

        // Returns a string representation of all the data currently stored
        public string PrintAllData()
        {
            string output = "";
            this.dataHistoryMut.WaitOne();
            foreach (float[] sample in data)
            {
                output += "Time: " + sample[0].ToString() + "- ";
                for (int channel = 1; channel < sample.Length; ++channel)
                {
                    if (channel == sample.Length - 1)
                    {
                        // Last channel in the sample
                        output += sample[channel].ToString() + "\n";
                    }
                    else
                    {
                        output += sample[channel].ToString() + ", ";
                    }
                }
            }
            this.dataHistoryMut.ReleaseMutex();
            return output;
        }

        // Returns the list of sample arrays
        public List<float[]> GetAllData()
        {
            return data;
        }

        // Writes to a CSV file the feature vector for each recorded epoch
        // Ex: Transform.HashCode {int}, Ch0 {float}, ... , ChN {float}
        public void WriteOutExampleData(string trainExampleFilename)
        {
            string path = "Assets/Data/" + trainExampleFilename;
            if (!File.Exists(path))
            {
                using (StreamWriter writer = File.CreateText(path))
                {
                    foreach (Epoch epoch in epochs)
                    {
                        float[] example = epoch.GetFeatureVector();
                        if (example != null)
                        {
                            writer.Write("{0},", epoch.GetEventOrigin().GetHashCode());
                            for (int i = 0; i < example.Length; ++i)
                            {
                                if (i == example.Length - 1)
                                {
                                    writer.Write("{0}", example[i]);
                                }
                                else
                                {
                                    writer.Write("{0},", example[i]);
                                }
                            }
                        }
                        writer.Write("\n");
                    }
                }
            }
            else
            {
                using (StreamWriter writer = File.AppendText(path))
                {
                    foreach (Epoch epoch in epochs)
                    {
                        float[] example = epoch.GetFeatureVector();
                        if (example != null)
                        {
                            writer.Write("{0},", epoch.GetEventOrigin().GetHashCode());
                            for (int i = 0; i < example.Length; ++i)
                            {
                                if (i == example.Length - 1)
                                {
                                    writer.Write("{0}", example[i]);
                                }
                                else
                                {
                                    writer.Write("{0},", example[i]);
                                }
                            }
                        }
                        writer.Write("\n");
                    }
                }
            }
        }

        // Writes to a CSV file the training labels for each recorded epoch
        // Ex: Tansform.HashCode {int}, label {0,1}
        public void WriteoutTrainLabels(string trainLabelFilename)
        {
            string path = "Assets/Data/" + trainLabelFilename;

            if (!File.Exists(path))
            {
                using (StreamWriter writer = File.CreateText(path))
                {
                    foreach (Epoch epoch in epochs)
                    {
                        if (epoch.GetData() != null)
                        {
                            writer.Write("{0}, {1}\n", epoch.GetEventOrigin().GetHashCode(), epoch.GetLabel());
                        }
                    }
                }
            }
            else
            {
                using (StreamWriter writer = File.AppendText(path))
                {
                    foreach (Epoch epoch in epochs)
                    {
                        if (epoch.GetData() != null)
                        {
                            writer.Write("{0}, {1}\n", epoch.GetEventOrigin().GetHashCode(), epoch.GetLabel());
                        }
                    }
                }
            }
        }

    }
}

